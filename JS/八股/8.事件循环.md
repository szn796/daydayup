# 事件循环

## 1.设计背景（为什么会有事件循环）

**首先，我们知道JS是一门单线程的语言，它运行在浏览器的渲染主线程中，而渲染主线程只有一个。**

**渲染主线程运行很多工作，例如解析HTML、解析CSS、计算样式、布局、渲染页面、执行JS。**

**如果使用同步的方式，就可能导致主线程阻塞，导致消息队列中后续的任务无法及时被执行，也就是出现卡死现象（也就是可能要执行某个js需要耗时5s，那么会导致页面的渲染需要在这5s后才可能执行）。**

**因此需要事件循环来解决这个问题，也就是实现“主线程不阻塞”、“异步任务有序执行”。**

**JavaScript为什么设计为单线程语言，主要为了避免多线程操作DOM时的竞态问题（如同时修改和删除同一个元素）。**

## 2.阐述一下事件循环

### 2.1.八股答案

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
在谷歌浏览器源码中，它通过for开启一个死循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列的末尾。
过去把消息队列分为宏任务队列和微任务队列，但是这种说法目前无法满足复杂的浏览器环境，取而代之的是一种更灵活的方式。
根据W3C官方的解释，每个任务都有不同的类型，同类型的任务必须在同一个队列中，不同的任务可以属于不同的队列（也就是任务A和任务B可能同属于队列A，并且所有的任务A和所有的任务B都必须属于队列A)。不同任务队列有不同的优先级。在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但是浏览器必须有一个微任务队列，微任务队列的任务一定具有最高的优先级。

### 2.2.宏任务和微任务

**从宏任务和微任务的角度来说：**

**首先执行所有的同步任务。遇到异步任务时，放到对应的任务队列。**

**执行完同步任务后，会去执行微任务，直到所有的微任务执行完毕。**

**才会去执行第一个宏任务，执行完一个宏任务后。**

**判断微任务队列中是否还存在，如果存在则执行完所有的微任务。再执行下一个宏任务。**

### 2.3.W3C新标准

在W3C最新解释中：

* 每个任务都有一个任务类型
  * 同一个任务类型的任务必须在一个队列（所有网络任务必须放在队列A）
  * 不同类型的任务可以分属于同一个的队列（例如：网络和定时器任务都可以放在队列A，但是不能网络放队列A又放队列B）。
  * 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。（将宏任务队列拆分成多个任务队列：例如延时队列、交互队列）
    * 延时队列：计时器的回调任务，优先级中
    * 交互队列：操作后产生的事件处理任务，优先级高
    * 微任务队列：最快执行的人物，优先级最高
  * 浏览器必须准备好一个微任务队列，微任务队列中的任务优先所有其他任务执行（微任务->VIP）
    也就是
  * 保留微任务队列的概念，微任务队列中的任务优先于所有其他任务的执行
  * 没有宏任务队列的概念，宏任务队列拆分成多个队列，只有一个宏任务处理不来

### 2.4.渲染主线程的角度

**从渲染主线程的角度来说：**

1. 在最开始的时候，**渲染主线程会进入无限循环**（while(true){xxx})
2. **每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环，如果没有，则进入休眠状态。**
3. **其他所有线程（包括其他进程的线程->网络进程的线程、浏览器进程的线程）可以向消息队列中添加任务。新任务会被添加到消息队列的末尾。再添加新任务时，如果主线程是休眠的，则会将其唤醒并继续循环拿去任务。**

**也就是在每次清空完微任务队列后，会判断是否需要渲染。在处理下一个宏任务。**

## 3.如何理解JS的异步

使用异步是为了解决主线程的阻塞。
JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。
渲染主线程运行很多工作，例如解析HTML、解析CSS、计算样式、布局、渲染页面、执行JS。
如果使用同步的方式，就可能导致主线程阻塞，导致消息队列中后续的任务无法及时被执行，也就是出现卡死现象。
所以浏览器使用异步的方式来避免。具体的做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续消息队列中的任务。当其他线程完成时，将事先传递的回调函数包装成任务，加入消息队列的末尾，等待主线程调度执行。
在这种异步情况下，保证了浏览器不会阻塞，能够单线程流畅运行。
